# ğŸš€ Text-to-SQL API

A flexible, production-ready Node.js API that converts natural language queries into SQL using AI models and executes them against various databases. Built with TypeScript and following SOLID principles for maximum extensibility.

## ğŸ“‹ Table of Contents

-   [Features](#features)
-   [Architecture](#architecture)
-   [Prerequisites](#prerequisites)
-   [Installation](#installation)
-   [Configuration](#configuration)
-   [Usage](#usage)
-   [API Reference](#api-reference)
-   [Project Structure](#project-structure)
-   [Adding New Providers](#adding-new-providers)
-   [Examples](#examples)
-   [Troubleshooting](#troubleshooting)
-   [Contributing](#contributing)
-   [License](#license)

## âœ¨ Features

-   **ğŸ¤– Multiple AI Providers**: Support for Ollama, OpenAI (extensible to more)
-   **ğŸ’¾ Multiple Databases**: PostgreSQL, MySQL, MongoDB (extensible)
-   **ğŸ”„ Runtime Configuration**: Choose AI model and database via npm scripts
-   **ğŸ—ï¸ Clean Architecture**: Interface-based design following SOLID principles
-   **âš¡ Type-Safe**: Written in TypeScript for better developer experience
-   **ğŸ”Œ Pluggable**: Easy to add new AI models or databases
-   **ğŸ“Š Schema-Aware**: Automatically retrieves and uses database schema
-   **ğŸ›¡ï¸ Error Handling**: Comprehensive error handling and validation
-   **ğŸ” Query Sanitization**: Extracts clean SQL from AI responses

## ğŸ›ï¸ Architecture

The application follows a layered architecture with clear separation of concerns:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Controller    â”‚ â† HTTP Request Handling
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Service      â”‚ â† Business Logic
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚         â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”
â”‚  AI  â”‚  â”‚  DB  â”‚ â† Provider Implementations
â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜
    â”‚         â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”
â”‚   Interfaces   â”‚ â† Abstract Contracts
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Design Patterns Used

-   **Strategy Pattern**: Swappable AI and Database providers
-   **Dependency Injection**: Services receive dependencies via constructor
-   **Factory Pattern**: Provider creation based on configuration
-   **Interface Segregation**: Clean contracts for extensibility

## ğŸ“¦ Prerequisites

Before you begin, ensure you have the following installed:

-   **Node.js** (v18 or higher)
-   **npm** or **yarn**
-   **TypeScript** (v5.x)
-   **Database**: PostgreSQL, MySQL, or MongoDB
-   **AI Provider**:
    -   Ollama (running locally) - [Installation Guide](https://ollama.ai)
    -   OR OpenAI API key

### Ollama Setup

```bash
# Install Ollama
curl -fsSL https://ollama.ai/install.sh | sh

# Pull the model
ollama pull llama3.2

# Verify Ollama is running
curl http://localhost:11434/api/tags
```

## ğŸ”§ Installation

1. **Clone the repository**

```bash
git clone https://github.com/yourusername/text-to-sql-api.git
cd text-to-sql-api
```

2. **Install dependencies**

```bash
npm install
```

3. **Set up environment variables**

Create a `.env` file in the root directory:

```env
# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_NAME=mydb
DB_USER=postgres
DB_PASSWORD=password

# Server Configuration
PORT=3000

# AI Provider Configuration
OLLAMA_BASE_URL=http://localhost:11434
OPENAI_API_KEY=your_openai_api_key_here
```

4. **Create your database**

```sql
-- PostgreSQL example
CREATE DATABASE mydb;

-- Create a sample table
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insert sample data
INSERT INTO users (name, email) VALUES
  ('John Doe', 'john@example.com'),
  ('Jane Smith', 'jane@example.com'),
  ('Bob Johnson', 'bob@example.com');
```

5. **Build the project**

```bash
npm run build
```

## âš™ï¸ Configuration

### Available Configurations

The application supports multiple provider combinations. Define them in `src/config/config.ts`:

```typescript
export const configs: { [key: string]: AppConfig } = {
  'llama3.2-postgres': {
    ai: { provider: 'ollama', model: 'llama3.2' },
    database: { provider: 'postgres', config: {...} }
  },
  'llama3.2-mysql': {
    ai: { provider: 'ollama', model: 'llama3.2' },
    database: { provider: 'mysql', config: {...} }
  },
  'gpt4-postgres': {
    ai: { provider: 'openai', model: 'gpt-4' },
    database: { provider: 'postgres', config: {...} }
  }
  // Add more combinations as needed
}
```

### Package.json Scripts

```json
{
	"scripts": {
		"build": "tsc",
		"start": "node dist/index.js",
		"dev": "ts-node src/index.ts",
		"start:llama3.2-postgres": "CONFIG=llama3.2-postgres npm run dev",
		"start:llama3.2-mysql": "CONFIG=llama3.2-mysql npm run dev",
		"start:gpt4-postgres": "CONFIG=gpt4-postgres npm run dev"
	}
}
```

## ğŸš€ Usage

### Starting the Server

Choose your AI model and database combination:

```bash
# Ollama + PostgreSQL
npm run start:llama3.2-postgres

# Ollama + MySQL
npm run start:llama3.2-mysql

# OpenAI GPT-4 + PostgreSQL
npm run start:gpt4-postgres
```

The server will start and display:

```
ğŸš€ Server running on port 3000
ğŸ“Š Database: postgres
ğŸ¤– AI Model: ollama:llama3.2
```

### Making Requests

#### Using cURL

```bash
curl -X POST http://localhost:3000/query \
  -H "Content-Type: application/json" \
  -d '{
    "query": "Show me all users created in the last 7 days"
  }'
```

#### Using JavaScript/Fetch

```javascript
const response = await fetch('http://localhost:3000/query', {
	method: 'POST',
	headers: {
		'Content-Type': 'application/json',
	},
	body: JSON.stringify({
		query: 'Find all users with gmail addresses',
	}),
})

const result = await response.json()
console.log(result)
```

#### Using Postman

1. Set method to `POST`
2. URL: `http://localhost:3000/query`
3. Headers: `Content-Type: application/json`
4. Body (raw JSON):

```json
{
	"query": "Count total users by month"
}
```

## ğŸ“¡ API Reference

### POST /query

Converts natural language to SQL and executes the query.

**Request Body:**

```json
{
	"query": "string - Natural language query"
}
```

**Response (Success - 200):**

```json
{
	"success": true,
	"data": {
		"query": "Show me all users created today",
		"generatedSQL": "SELECT * FROM users WHERE DATE(created_at) = CURRENT_DATE",
		"result": {
			"rows": [
				{
					"id": 1,
					"name": "John Doe",
					"email": "john@example.com",
					"created_at": "2024-12-04T10:30:00Z"
				}
			],
			"rowCount": 1
		},
		"executionTime": 1523
	}
}
```

**Response (Error - 400/500):**

```json
{
	"success": false,
	"error": "Error message describing what went wrong"
}
```

### GET /health

Health check endpoint.

**Response (200):**

```json
{
	"status": "ok"
}
```

## ğŸ“ Project Structure

```
text-to-sql-api/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ interfaces/
â”‚   â”‚   â”œâ”€â”€ IAIProvider.ts           # AI provider interface
â”‚   â”‚   â””â”€â”€ IDatabaseProvider.ts      # Database provider interface
â”‚   â”œâ”€â”€ providers/
â”‚   â”‚   â”œâ”€â”€ ai/
â”‚   â”‚   â”‚   â”œâ”€â”€ OllamaProvider.ts     # Ollama implementation
â”‚   â”‚   â”‚   â””â”€â”€ OpenAIProvider.ts     # OpenAI implementation
â”‚   â”‚   â””â”€â”€ database/
â”‚   â”‚       â”œâ”€â”€ PostgresProvider.ts   # PostgreSQL implementation
â”‚   â”‚       â”œâ”€â”€ MySQLProvider.ts      # MySQL implementation
â”‚   â”‚       â””â”€â”€ MongoDBProvider.ts    # MongoDB implementation
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ TextToSQLService.ts       # Core business logic
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â””â”€â”€ QueryController.ts        # HTTP request handling
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ config.ts                 # Configuration management
â”‚   â”œâ”€â”€ app.ts                        # Express app setup
â”‚   â””â”€â”€ index.ts                      # Entry point
â”œâ”€â”€ dist/                             # Compiled JavaScript (generated)
â”œâ”€â”€ .env                              # Environment variables
â”œâ”€â”€ .gitignore
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

## ğŸ”Œ Adding New Providers

### Adding a New AI Provider

1. **Create the provider class**

```typescript
// src/providers/ai/OpenAIProvider.ts
import { IAIProvider } from '../../interfaces/IAIProvider'
import OpenAI from 'openai'

export class OpenAIProvider implements IAIProvider {
	private client: OpenAI
	private model: string

	constructor(model: string, apiKey: string) {
		this.model = model
		this.client = new OpenAI({ apiKey })
	}

	async generateSQL(naturalLanguageQuery: string, schema: string): Promise<string> {
		const response = await this.client.chat.completions.create({
			model: this.model,
			messages: [
				{
					role: 'system',
					content: 'You are a SQL expert. Generate only SQL queries without explanation.',
				},
				{
					role: 'user',
					content: `Schema:\n${schema}\n\nQuery: ${naturalLanguageQuery}`,
				},
			],
			temperature: 0.1,
		})

		return response.choices[0].message.content || ''
	}
}
```

2. **Update the factory in App.ts**

```typescript
private createAIProvider(): IAIProvider {
  switch (this.config.ai.provider) {
    case 'ollama':
      return new OllamaProvider(this.config.ai.model, this.config.ai.baseUrl);
    case 'openai':
      return new OpenAIProvider(this.config.ai.model, this.config.ai.apiKey);
    default:
      throw new Error(`Unsupported AI provider: ${this.config.ai.provider}`);
  }
}
```

3. **Add configuration**

```typescript
'gpt4-postgres': {
  ai: {
    provider: 'openai',
    model: 'gpt-4',
    apiKey: process.env.OPENAI_API_KEY
  },
  database: { ... }
}
```

### Adding a New Database Provider

1. **Create the provider class**

```typescript
// src/providers/database/MySQLProvider.ts
import mysql from 'mysql2/promise'
import { IDatabaseProvider, QueryResult } from '../../interfaces/IDatabaseProvider'

export class MySQLProvider implements IDatabaseProvider {
	private connection: mysql.Connection
	private config: mysql.ConnectionOptions

	constructor(config: mysql.ConnectionOptions) {
		this.config = config
	}

	async connect(): Promise<void> {
		this.connection = await mysql.createConnection(this.config)
		console.log('âœ“ Connected to MySQL database')
	}

	async disconnect(): Promise<void> {
		await this.connection.end()
		console.log('âœ“ Disconnected from MySQL database')
	}

	async executeQuery(query: string): Promise<QueryResult> {
		const [rows] = await this.connection.execute(query)
		return {
			rows: rows as any[],
			rowCount: (rows as any[]).length,
		}
	}

	async getSchema(): Promise<string> {
		const [tables] = await this.connection.query('SHOW TABLES')
		// Format schema similar to PostgresProvider
		// ... implementation
		return schema
	}
}
```

2. **Update the factory in App.ts**

```typescript
private createDatabaseProvider(): IDatabaseProvider {
  switch (this.config.database.provider) {
    case 'postgres':
      return new PostgresProvider(this.config.database.config);
    case 'mysql':
      return new MySQLProvider(this.config.database.config);
    default:
      throw new Error(`Unsupported database provider`);
  }
}
```

3. **Add npm script**

```json
"start:llama3.2-mysql": "CONFIG=llama3.2-mysql npm run dev"
```

## ğŸ’¡ Examples

### Example Queries

**Get all records:**

```
"Show me all users"
â†’ SELECT * FROM users
```

**Filtered queries:**

```
"Find users created in the last 30 days"
â†’ SELECT * FROM users WHERE created_at >= NOW() - INTERVAL '30 days'
```

**Aggregations:**

```
"Count users by registration month"
â†’ SELECT DATE_TRUNC('month', created_at) as month, COUNT(*)
  FROM users GROUP BY month ORDER BY month
```

**Joins:**

```
"Show all orders with customer names"
â†’ SELECT o.*, c.name FROM orders o
  JOIN customers c ON o.customer_id = c.id
```

**Complex queries:**

```
"Find top 5 customers by total order value"
â†’ SELECT c.name, SUM(o.total) as total_spent
  FROM customers c
  JOIN orders o ON c.id = o.customer_id
  GROUP BY c.id, c.name
  ORDER BY total_spent DESC
  LIMIT 5
```

## ğŸ› Troubleshooting

### Common Issues

#### 1. Ollama Connection Error

**Error:** `Failed to connect to Ollama at http://localhost:11434`

**Solution:**

```bash
# Check if Ollama is running
curl http://localhost:11434/api/tags

# If not running, start Ollama
ollama serve

# Pull the model if not available
ollama pull llama3.2
```

#### 2. Database Connection Error

**Error:** `Failed to connect to PostgreSQL`

**Solution:**

-   Verify database credentials in `.env`
-   Ensure database server is running
-   Check network connectivity and firewall rules
-   Verify database exists: `psql -U postgres -l`

#### 3. SQL Generation Issues

**Error:** Generated SQL is wrapped in markdown or contains explanations

**Solution:**
The `extractSQL()` method should handle this, but you can improve the prompt:

-   Set temperature to 0.1 for more deterministic output
-   Add explicit instructions: "Return ONLY the SQL query, no explanations"
-   Use system prompts to enforce behavior

#### 4. TypeScript Compilation Errors

**Error:** `Cannot find module` or type errors

**Solution:**

```bash
# Clean and reinstall dependencies
rm -rf node_modules dist
npm install

# Rebuild
npm run build
```

### Debug Mode

Enable detailed logging:

```typescript
// In your provider classes
console.log('Generated SQL:', sql)
console.log('Schema:', schema)
console.log('Query Result:', result)
```

## ğŸ§ª Testing

### Manual Testing

```bash
# Start the server
npm run start:llama3.2-postgres

# Test health endpoint
curl http://localhost:3000/health

# Test query endpoint
curl -X POST http://localhost:3000/query \
  -H "Content-Type: application/json" \
  -d '{"query": "Show me all users"}'
```

### Unit Testing (Future Enhancement)

```typescript
// Example test structure
describe('TextToSQLService', () => {
	it('should generate and execute SQL', async () => {
		const mockAI = new MockAIProvider()
		const mockDB = new MockDatabaseProvider()
		const service = new TextToSQLService(mockAI, mockDB)

		const result = await service.processQuery('Find all users')
		expect(result.generatedSQL).toContain('SELECT')
	})
})
```

## ğŸ¤ Contributing

Contributions are welcome! Please follow these steps:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

### Coding Standards

-   Follow TypeScript best practices
-   Use meaningful variable and function names
-   Add comments for complex logic
-   Maintain the existing architecture patterns
-   Write clean, testable code

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ™ Acknowledgments

-   [Ollama](https://ollama.ai) - Local LLM runtime
-   [OpenAI](https://openai.com) - GPT models
-   [PostgreSQL](https://www.postgresql.org) - Database
-   [Express.js](https://expressjs.com) - Web framework
-   [TypeScript](https://www.typescriptlang.org) - Type safety

## ğŸ“ Support

-   Create an issue for bug reports or feature requests
-   Email: support@example.com
-   Documentation: [Wiki](https://github.com/yourusername/text-to-sql-api/wiki)

## ğŸ—ºï¸ Roadmap

-   [ ] Add unit and integration tests
-   [ ] Implement query validation and SQL injection prevention
-   [ ] Add caching layer for frequently used queries
-   [ ] Support for query history and analytics
-   [ ] WebSocket support for real-time query streaming
-   [ ] Docker containerization
-   [ ] Kubernetes deployment manifests
-   [ ] Rate limiting and authentication
-   [ ] Multi-tenant support
-   [ ] Query optimization suggestions

---

**Made with â¤ï¸ by [Your Name]**

â­ Star this repo if you find it helpful!
